# -*- coding: utf-8 -*-
"""TSP_AnsatzFINE (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c8fvWlOcz1ApUT91uvyQBs4_fT1ad2aD
"""

#pip install qiskit

#pip install qiskit_ibm_runtime

#pip install qiskit_optimization

#pip install qiskit-ibmq-provider

# Importing standard Qiskit libraries
from qiskit import IBMQ, QuantumCircuit, transpile
#from qiskit.tools.jupyter import *
from qiskit.visualization import *
#from ibm_quantum_widgets import *

# qiskit-ibmq-provider has been deprecated.
# Please see the Migration Guides in https://ibm.biz/provider_migration_guide for more detail.
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Estimator, Session, Options

# Loading your IBM Quantum account(s)
#service = QiskitRuntimeService(channel="ibm_quantum")

# Invoke a primitive. For more details see https://qiskit.org/documentation/partners/qiskit_ibm_runtime/tutorials.html
# result = Sampler("ibmq_qasm_simulator").run(circuits).result()

# Commented out IPython magic to ensure Python compatibility.
#import qiskit.tools.jupyter

# %qiskit_version_table

# useful additional packages
import matplotlib.pyplot as plt
import numpy as np
import pylab

import networkx as nx

from qiskit.tools.visualization import plot_histogram
from qiskit.circuit.library import TwoLocal
from qiskit_optimization.applications import Maxcut, Tsp
from qiskit_algorithms import SamplingVQE, NumPyMinimumEigensolver
from qiskit_algorithms.optimizers import SPSA, COBYLA
from qiskit_algorithms.utils import algorithm_globals
from qiskit.primitives import Sampler
from qiskit_optimization.algorithms import MinimumEigenOptimizer

from qiskit_optimization.converters import QuadraticProgramToQubo

from qiskit.circuit import QuantumCircuit, Parameter, ParameterVector

from itertools import permutations #per brutal approches TSP

#draw a graph coloring the nodes

#funzione per disegnare un grafo con nodi colorati
def draw_graph(G, colors, pos):
    default_axes = plt.axes(frameon=True)
    nx.draw_networkx(G, node_color=colors, node_size=600, alpha=0.8, ax=default_axes, pos=pos)
    edge_labels = nx.get_edge_attributes(G, "weight")
    nx.draw_networkx_edge_labels(G, pos=pos, edge_labels=edge_labels)

#funzione per disegnare un cammino su un grafo
def draw_tsp_solution(G, order, colors, pos):
    G2 = nx.DiGraph()
    G2.add_nodes_from(G)
    n = len(order)
    for i in range(n):
        j = (i + 1) % n
        G2.add_edge(order[i], order[j], weight=G[order[i]][order[j]]["weight"])
    default_axes = plt.axes(frameon=True)
    nx.draw_networkx(
        G2, node_color=colors, edge_color="b", node_size=600, alpha=0.8, ax=default_axes, pos=pos
    )
    edge_labels = nx.get_edge_attributes(G2, "weight")
    nx.draw_networkx_edge_labels(G2, pos, font_color="b", edge_labels=edge_labels)

### TSP

# Generating a random graph
n = 3 # num
num_qubits = n**2
tsp = Tsp.create_random_instance(n)
G=tsp.graph


# Creating a specific graph

#n=3 #numero di nodi
#G= nx.Graph() # definizione del grafo
#G.add_nodes_from(np.arange(0, n, 1)) # aggiungo i vertici
#elist = [(0, 1, 1), (0, 2, 1), (1, 2, 3)] # definisco la lista degli archi [(i,j,peso)]
### tuple is (i,j,weight) where (i,j) is the edge
#G.add_weighted_edges_from(elist)# aggiungo gli archi al grafo

#tsp=Tsp(G)

# grafico
adj_matrix = nx.to_numpy_array(G)
print("distance\n", adj_matrix)
colors = ["r" for node in G.nodes]
pos = nx.spring_layout(G)
draw_graph(tsp.graph, colors, pos)

## define the ising model

qp = tsp.to_quadratic_program()
qp2qubo= QuadraticProgramToQubo()
qubo = qp2qubo.convert(qp)
qubitOp, offset = qubo.to_ising()

# create the Ansatz: dato il numero di nodi del grafo costruisco l'Ansatz 

def W_circuit(QC, n, q1n, theta):
    QC.x(q1n)
    for j in range(q1n+1,q1n+n,1):
        QC.ry(theta[j-1], j)
        QC.cz(j-1,j)
        QC.ry(-theta[j-1], j)
    for j in range(q1n+1,q1n+n,1):
        QC.cx(j,j-1)

def base_circuit(QC, n, theta):
    #theta1 = ParameterVector('theta2', 1)
    QC.x(0)
    QC.ry(theta[1], 1)
    QC.cz(0,1)
    QC.ry(-theta[1], 1)
    QC.cx(1,0)
    QC.cx(1,n)
    QC.cx(0,n+1)

qc = QuantumCircuit(n**2)
theta = ParameterVector('theta', n**2)
base_circuit(qc,n, theta)
for i in range(3,n+1,1):
    W_circuit(qc, i, n*(i-1), theta)
for k in range (3,n+1,1):
    for v in range(1,k,1):
        for p in range(1,k,1):
            qc.cswap(n*(k-1)+v-1,n*(p-1)+n-(n-k)-1,n*(p-1)+v-1)
ansatz=qc

#####

from qiskit_ibm_runtime import QiskitRuntimeService, Session, Sampler #solo per eseguire il cicuito in runtime

my_api_token = '...'#da inserire

service = QiskitRuntimeService(channel="ibm_quantum", token= my_api_token)

#####

# run the VQE

optimizer = COBYLA(maxiter=35) #define the optimizer
backend=service.backend("ibmq_qasm_simulator") #scegli backend
with Session (backend=backend) as s:
    vqe_mes= SamplingVQE(sampler=Sampler(backend=backend, session=s), ansatz=ansatz, optimizer=optimizer) #define the SamplingVqe
    # run SamplingVQE
    vqe = MinimumEigenOptimizer ( vqe_mes )
    result = vqe . solve (qp)
s.close()

# print the result

z=tsp.interpret(result)
print("solution:", z)
print("solution objective:", tsp.tsp_value(z, adj_matrix))
draw_tsp_solution(tsp.graph, z, colors, pos)



